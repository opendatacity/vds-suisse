var fs = require('fs');
var utils = require('utils');

exports.Graph = function () {
	var me = this;

	var knownNodes = {};
	utils.readListOfObjects('data/contacts/known_nodes.tsv').forEach(function (node, index) {
		node.index = index;
		knownNodes[node.Name] = node;
	})


	me.calculateEdges = function (events) {
		console.log('Calc Graph');

		var ignoreContacts = {};
		fs.readFileSync('data/contacts/ignore_nodes.tsv', 'utf8').split('\n').forEach(function (contact) {
			ignoreContacts[contact] = true;
		});

		var nodes = {};
		var edges = {};
		var unknownNodes = [];
		var count = 0;

		var connections = events.map(function (event) {
			var addresses = event.to.concat([event.from]);

			// remove duplicates
			for (var i = 0; i < addresses.length; i++) {
				if (addresses[i]) {
					for (var j = i+1; j < addresses.length; j++) {
						if (addresses[i].contact == addresses[j].contact) {
							addresses[i] = false;
							break;
						}
					}
				}
			}

			// Filter
			addresses = addresses.filter(function (address) {
				if (!address) return false;
				if (ignoreContacts[address.contact]) return false;
				return true;
			})

			// Add nodes
			addresses.forEach(function (address) {

				var contact = address.contact;

				if (!nodes[contact]) {
					nodes[contact] = {
						label:contact,
						count:0,
						intensity:0,
						weight:0,
						edges:0,
						addresses:{},
						org:address.org,
					};
				}

				nodes[contact].count++;
				nodes[contact].intensity += 1/addresses.length;
				nodes[contact].addresses[address.address] = true;
			})

			return addresses;
		});

		connections.forEach(function (addresses) {
			// Add edge
			if (addresses.length > 1) {
				var weight = 1/(addresses.length-1) + 0.01;
				for (var i = 0; i < addresses.length; i++) {
					var contact1 = addresses[i].contact;
					for (var j = i+1; j < addresses.length; j++) {
						var contact2 = addresses[j].contact;

						if (nodes[contact1] && nodes[contact2]) {
							var contactA, contactB;
							if (contact1 < contact2) {
								contactA = contact1; contactB = contact2;
							} else {
								contactA = contact2; contactB = contact1;
							}
							
							var edgeName = contactA+'_'+contactB;


							if (!edges[edgeName]) edges[edgeName] = {source:contactA, target:contactB, weight:0};

							nodes[contact1].edges  += 1;
							nodes[contact2].edges  += 1;

							nodes[contact1].weight += weight;
							nodes[contact2].weight += weight;

							edges[edgeName].weight += weight;
						}
					}
				}
			}
		})

		var orgCount = 0;
		var orgs = {'':0};

		nodeList = Object.keys(nodes).map(function (key) {
			var node = nodes[key];
			
			node.ok = false;
			if (!node) return false;
			if (node.weight < 10) return false; //5
			if (node.edges  < 10) return false;
			if (node.count  < 20) return false; //10

			var size = node.weight + node.intensity;

			node.ok = true;
			node.maxWeight = 0;

			var org = 0;
			var label = node.label;
			if (knownNodes[node.label]) {
				var knownNode = knownNodes[node.label];
				node.index = knownNode.index;
				org = knownNode['angezeigte Gruppe'];
				label = knownNode['angezeigtes Pseudonym']+' ('+org+')';
				if (!orgs[org]) {
					orgCount++;
					orgs[org] = orgCount;
				}
				org = orgs[org];

			} else {
				unknownNodes.push([
					node.label,
					size,
					node.org,
					Object.keys(node.addresses).join(', ')
				].join('\t'));
			}

			return [node.index, label, size.toFixed(2), org].join('\t');

		}).filter(function (node) {
			return node;
		});
		nodeList.unshift('Id\tLabel\tSize\tClass');

		fs.writeFileSync('output/nodes.csv', nodeList.join('\n'), 'utf8');

		fs.writeFileSync('output/unknownNodes.csv', unknownNodes.join('\n'), 'utf8');



		edgeList = Object.keys(edges).map(function (key) {
			var edge = edges[key];

			if (!nodes[edge.source].ok) return false;
			if (!nodes[edge.target].ok) return false;

			if (nodes[edge.source].maxWeight < edge.weight) nodes[edge.source].maxWeight = edge.weight;
			if (nodes[edge.target].maxWeight < edge.weight) nodes[edge.target].maxWeight = edge.weight;

			return edge;
		}).filter(function (edge) {
			return edge;
		})

		edgeList = edgeList.map(function (edge) {
			var f = Math.min(nodes[edge.source].maxWeight, nodes[edge.target].maxWeight);
			return [
				nodes[edge.source].index,
				nodes[edge.target].index,
				edge.weight/f,
				'Undirected'
			].join('\t');
		})

		edgeList.unshift('Source\tTarget\tWeight\tType');

		fs.writeFileSync('output/edges.csv', edgeList.join('\n'), 'utf8');

		console.log(nodeList.length, edgeList.length);
	}

	return me;
}